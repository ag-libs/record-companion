package io.github.recordcompanion.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import io.github.recordcompanion.annotations.Builder;
import java.io.IOException;
import java.util.List;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;

/** Generates builder pattern implementations for record classes. */
public class BuilderGenerator {

  private final ProcessingEnvironment processingEnv;

  public BuilderGenerator(ProcessingEnvironment processingEnv) {
    this.processingEnv = processingEnv;
  }

  /** Generates a companion class with builder methods for the given record. */
  public void generateCompanionClass(TypeElement recordElement) throws IOException {
    String recordName = recordElement.getSimpleName().toString();
    String companionName = recordName + "Companion";
    String packageName =
        processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();

    ClassName recordClass = ClassName.get(packageName, recordName);
    ClassName companionClass = ClassName.get(packageName, companionName);

    List<? extends RecordComponentElement> components = recordElement.getRecordComponents();

    // Generate the Updater interface
    TypeSpec updaterInterface = generateUpdaterInterface(components);

    // Generate the Builder inner class
    TypeSpec builderClass = generateBuilderClass(recordClass, components);

    // Generate the Companion class
    TypeSpec companion =
        TypeSpec.classBuilder(companionName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc(
                "Generated companion class for {@link $T} record with builder pattern support.\n",
                recordClass)
            .addJavadoc("@generated by RecordCompanion annotation processor\n")
            .addType(updaterInterface)
            .addType(builderClass)
            .addMethod(generateBuilderMethod(companionClass))
            .addMethod(generateBuilderWithExistingMethod(recordClass, companionClass, components))
            .addMethod(generateWithMethod(recordClass, companionClass, components))
            .build();

    // Write the companion class to a file
    JavaFile javaFile = JavaFile.builder(packageName, companion).skipJavaLangImports(true).build();

    javaFile.writeTo(processingEnv.getFiler());
  }

  private TypeSpec generateUpdaterInterface(List<? extends RecordComponentElement> components) {
    TypeSpec.Builder updaterBuilder =
        TypeSpec.interfaceBuilder("Updater")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .addJavadoc("Interface for updating record values without exposing build method.\n");

    // Add setter method declarations for each component
    for (RecordComponentElement component : components) {
      String componentName = component.getSimpleName().toString();
      TypeMirror componentType = component.asType();

      // Always generate the original setter method
      MethodSpec setterMethod =
          MethodSpec.methodBuilder(componentName)
              .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
              .addParameter(ClassName.get(componentType), componentName)
              .returns(ClassName.bestGuess("Updater"))
              .addJavadoc("Sets the $N value.\n", componentName)
              .addJavadoc("@param $N the new $N value\n", componentName, componentName)
              .addJavadoc("@return this updater for method chaining\n")
              .build();

      updaterBuilder.addMethod(setterMethod);

      // Generate overloaded method for @Builder-annotated record types
      if (isBuilderAnnotatedRecord(component)) {
        DeclaredType declaredType = (DeclaredType) componentType;
        TypeElement nestedRecordElement = (TypeElement) declaredType.asElement();
        ClassName nestedCompanionClass = getCompanionClassName(nestedRecordElement);
        String updaterParamName = generateUpdaterParameterName(nestedRecordElement.getSimpleName().toString());

        ClassName consumerType = ClassName.get("java.util.function", "Consumer");
        ParameterizedTypeName nestedUpdaterConsumerType =
            ParameterizedTypeName.get(consumerType, nestedCompanionClass.nestedClass("Updater"));

        MethodSpec nestedSetterMethod =
            MethodSpec.methodBuilder(componentName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addParameter(nestedUpdaterConsumerType, updaterParamName)
                .returns(ClassName.bestGuess("Updater"))
                .addJavadoc("Updates the $N value using a fluent updater.\n", componentName)
                .addJavadoc(
                    "@param $N consumer that receives an updater for the nested $N\n",
                    updaterParamName,
                    componentName)
                .addJavadoc("@return this updater for method chaining\n")
                .build();

        updaterBuilder.addMethod(nestedSetterMethod);
      }
    }

    return updaterBuilder.build();
  }

  private TypeSpec generateBuilderClass(
      ClassName recordClass, List<? extends RecordComponentElement> components) {
    TypeSpec.Builder builderBuilder =
        TypeSpec.classBuilder("Builder")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
            .addSuperinterface(ClassName.bestGuess("Updater"));

    // Add fields for each component
    for (RecordComponentElement component : components) {
      builderBuilder.addField(
          ClassName.get(component.asType()),
          component.getSimpleName().toString(),
          Modifier.PRIVATE);
    }

    // Add setter methods for each component
    for (RecordComponentElement component : components) {
      String componentName = component.getSimpleName().toString();
      TypeMirror componentType = component.asType();

      // Always generate the original setter method
      MethodSpec setterMethod =
          MethodSpec.methodBuilder(componentName)
              .addModifiers(Modifier.PUBLIC)
              .addParameter(ClassName.get(componentType), componentName)
              .returns(ClassName.bestGuess("Builder"))
              .addStatement("this.$N = $N", componentName, componentName)
              .addStatement("return this")
              .build();

      builderBuilder.addMethod(setterMethod);

      // Generate overloaded method for @Builder-annotated record types
      if (isBuilderAnnotatedRecord(component)) {
        DeclaredType declaredType = (DeclaredType) componentType;
        TypeElement nestedRecordElement = (TypeElement) declaredType.asElement();
        ClassName nestedCompanionClass = getCompanionClassName(nestedRecordElement);
        String updaterParamName = generateUpdaterParameterName(nestedRecordElement.getSimpleName().toString());

        ClassName consumerType = ClassName.get("java.util.function", "Consumer");
        ParameterizedTypeName nestedUpdaterConsumerType =
            ParameterizedTypeName.get(consumerType, nestedCompanionClass.nestedClass("Updater"));

        CodeBlock nestedSetterBody = generateNestedSetterBody(componentName, nestedCompanionClass, updaterParamName);

        MethodSpec nestedSetterMethod =
            MethodSpec.methodBuilder(componentName)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(nestedUpdaterConsumerType, updaterParamName)
                .returns(ClassName.bestGuess("Builder"))
                .addCode(nestedSetterBody)
                .build();

        builderBuilder.addMethod(nestedSetterMethod);
      }
    }

    // Add build() method
    CodeBlock.Builder buildMethodBody = CodeBlock.builder();
    buildMethodBody.add("return new $T(", recordClass);

    for (int i = 0; i < components.size(); i++) {
      if (i > 0) buildMethodBody.add(", ");
      buildMethodBody.add("$N", components.get(i).getSimpleName().toString());
    }
    buildMethodBody.add(")");

    MethodSpec buildMethod =
        MethodSpec.methodBuilder("build")
            .addModifiers(Modifier.PUBLIC)
            .returns(recordClass)
            .addStatement(buildMethodBody.build())
            .build();

    builderBuilder.addMethod(buildMethod);

    return builderBuilder.build();
  }

  private MethodSpec generateBuilderMethod(ClassName companionClass) {
    return MethodSpec.methodBuilder("builder")
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .returns(companionClass.nestedClass("Builder"))
        .addStatement("return new Builder()")
        .addJavadoc("Creates a new builder instance.\n")
        .addJavadoc("@return a new builder instance\n")
        .build();
  }

  private MethodSpec generateBuilderWithExistingMethod(
      ClassName recordClass,
      ClassName companionClass,
      List<? extends RecordComponentElement> components) {
    return MethodSpec.methodBuilder("builder")
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(recordClass, "existing")
        .returns(companionClass.nestedClass("Builder"))
        .addJavadoc(
            "Creates a new builder instance initialized with values from an existing record.\n")
        .addJavadoc("@param existing the existing record to copy values from\n")
        .addJavadoc("@return a new builder instance with copied values\n")
        .addCode(generateBuilderWithExistingBody(components))
        .build();
  }

  private CodeBlock generateBuilderWithExistingBody(
      List<? extends RecordComponentElement> components) {
    CodeBlock.Builder body = CodeBlock.builder();
    body.addStatement("Builder builder = new Builder()");

    // Copy all values from existing record
    for (RecordComponentElement component : components) {
      String componentName = component.getSimpleName().toString();
      body.addStatement("builder.$N = existing.$N()", componentName, componentName);
    }

    body.addStatement("return builder");
    return body.build();
  }

  private MethodSpec generateWithMethod(
      ClassName recordClass,
      ClassName companionClass,
      List<? extends RecordComponentElement> components) {
    ClassName consumerType = ClassName.get("java.util.function", "Consumer");
    ParameterizedTypeName updaterConsumerType =
        ParameterizedTypeName.get(consumerType, companionClass.nestedClass("Updater"));

    return MethodSpec.methodBuilder("with")
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(recordClass, "existing")
        .addParameter(updaterConsumerType, "u")
        .returns(recordClass)
        .addJavadoc(
            "Creates a new record instance by applying modifications to an existing record.\n")
        .addJavadoc("@param existing the existing record to base the new record on\n")
        .addJavadoc(
            "@param u a consumer that receives an updater initialized with the existing record's values\n")
        .addJavadoc("@return a new record instance with the applied modifications\n")
        .addCode(generateWithMethodBody(components))
        .build();
  }

  private CodeBlock generateWithMethodBody(List<? extends RecordComponentElement> components) {
    CodeBlock.Builder body = CodeBlock.builder();
    body.addStatement("Builder builder = builder(existing)");
    body.addStatement("u.accept(builder)");
    body.addStatement("return builder.build()");

    return body.build();
  }

  /** Generates the method body for nested record setter methods. */
  private CodeBlock generateNestedSetterBody(String componentName, ClassName nestedCompanionClass, String parameterName) {
    CodeBlock.Builder body = CodeBlock.builder();

    // Update existing nested record or create new one if null
    body.beginControlFlow("if (this.$N != null)", componentName);
    body.addStatement(
        "this.$N = $T.with(this.$N, $N)",
        componentName,
        nestedCompanionClass,
        componentName,
        parameterName);
    body.nextControlFlow("else");
    body.addStatement(
        "this.$N = $T.with($T.builder().build(), $N)",
        componentName,
        nestedCompanionClass,
        nestedCompanionClass,
        parameterName);
    body.endControlFlow();
    body.addStatement("return this");

    return body.build();
  }

  /** Checks if a record component type is a record with @Builder annotation. */
  private boolean isBuilderAnnotatedRecord(RecordComponentElement component) {
    TypeMirror componentType = component.asType();

    if (!(componentType instanceof DeclaredType)) {
      return false;
    }

    DeclaredType declaredType = (DeclaredType) componentType;
    TypeElement typeElement = (TypeElement) declaredType.asElement();

    // Check if it's a record and has @Builder annotation
    return typeElement.getKind() == ElementKind.RECORD
        && typeElement.getAnnotation(Builder.class) != null;
  }

  /** Gets the companion class name for a given record type. */
  private ClassName getCompanionClassName(TypeElement recordElement) {
    String packageName =
        processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();
    String recordName = recordElement.getSimpleName().toString();
    String companionName = recordName + "Companion";
    return ClassName.get(packageName, companionName);
  }

  /**
   * Generates a short parameter name from a class name by taking first letters of camelCase words + 'u'.
   * Examples: Address -> au, PersonUpdater -> pu, MyType -> mtu
   */
  private String generateUpdaterParameterName(String className) {
    StringBuilder result = new StringBuilder();
    
    // Add first character (always lowercase)
    if (!className.isEmpty()) {
      result.append(Character.toLowerCase(className.charAt(0)));
    }
    
    // Add first letter of each subsequent camelCase word
    for (int i = 1; i < className.length(); i++) {
      if (Character.isUpperCase(className.charAt(i))) {
        result.append(Character.toLowerCase(className.charAt(i)));
      }
    }
    
    // Add 'u' suffix
    result.append('u');
    
    return result.toString();
  }
}
