package io.github.recordcompanion.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import java.io.IOException;
import java.util.List;

/**
 * Generates builder pattern implementations for record classes.
 */
public class BuilderGenerator {

    private final ProcessingEnvironment processingEnv;

    public BuilderGenerator(ProcessingEnvironment processingEnv) {
        this.processingEnv = processingEnv;
    }

    /**
     * Generates a companion class with builder methods for the given record.
     */
    public void generateCompanionClass(TypeElement recordElement) throws IOException {
        String recordName = recordElement.getSimpleName().toString();
        String companionName = recordName + "Companion";
        String packageName = processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();
        
        ClassName recordClass = ClassName.get(packageName, recordName);
        ClassName companionClass = ClassName.get(packageName, companionName);
        
        List<? extends RecordComponentElement> components = recordElement.getRecordComponents();
        
        // Generate the Builder inner class
        TypeSpec builderClass = generateBuilderClass(recordClass, components);
        
        // Generate the Companion class
        TypeSpec companion = TypeSpec.classBuilder(companionName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc("Generated companion class for {@link $T} record with builder pattern support.\n", recordClass)
            .addJavadoc("@generated by RecordCompanion annotation processor\n")
            .addType(builderClass)
            .addMethod(generateBuilderMethod(companionClass))
            .addMethod(generateBuilderWithExistingMethod(recordClass, companionClass, components))
            .addMethod(generateWithMethod(recordClass, companionClass, components))
            .build();
        
        // Write the companion class to a file
        JavaFile javaFile = JavaFile.builder(packageName, companion)
            .skipJavaLangImports(true)
            .build();
        
        javaFile.writeTo(processingEnv.getFiler());
    }

    private TypeSpec generateBuilderClass(ClassName recordClass, List<? extends RecordComponentElement> components) {
        TypeSpec.Builder builderBuilder = TypeSpec.classBuilder("Builder")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);
        
        // Add fields for each component
        for (RecordComponentElement component : components) {
            builderBuilder.addField(
                ClassName.get(component.asType()),
                component.getSimpleName().toString(),
                Modifier.PRIVATE
            );
        }
        
        // Add setter methods for each component
        for (RecordComponentElement component : components) {
            String componentName = component.getSimpleName().toString();
            TypeMirror componentType = component.asType();
            
            MethodSpec setterMethod = MethodSpec.methodBuilder(componentName)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(ClassName.get(componentType), componentName)
                .returns(ClassName.bestGuess("Builder"))
                .addStatement("this.$N = $N", componentName, componentName)
                .addStatement("return this")
                .build();
            
            builderBuilder.addMethod(setterMethod);
        }
        
        // Add build() method
        CodeBlock.Builder buildMethodBody = CodeBlock.builder();
        buildMethodBody.add("return new $T(", recordClass);
        
        for (int i = 0; i < components.size(); i++) {
            if (i > 0) buildMethodBody.add(", ");
            buildMethodBody.add("$N", components.get(i).getSimpleName().toString());
        }
        buildMethodBody.add(")");
        
        MethodSpec buildMethod = MethodSpec.methodBuilder("build")
            .addModifiers(Modifier.PUBLIC)
            .returns(recordClass)
            .addStatement(buildMethodBody.build())
            .build();
        
        builderBuilder.addMethod(buildMethod);
        
        return builderBuilder.build();
    }

    private MethodSpec generateBuilderMethod(ClassName companionClass) {
        return MethodSpec.methodBuilder("builder")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .returns(companionClass.nestedClass("Builder"))
            .addStatement("return new Builder()")
            .addJavadoc("Creates a new builder instance.\n")
            .addJavadoc("@return a new builder instance\n")
            .build();
    }

    private MethodSpec generateBuilderWithExistingMethod(ClassName recordClass, ClassName companionClass, List<? extends RecordComponentElement> components) {
        return MethodSpec.methodBuilder("builder")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .addParameter(recordClass, "existing")
            .returns(companionClass.nestedClass("Builder"))
            .addJavadoc("Creates a new builder instance initialized with values from an existing record.\n")
            .addJavadoc("@param existing the existing record to copy values from\n")
            .addJavadoc("@return a new builder instance with copied values\n")
            .addCode(generateBuilderWithExistingBody(components))
            .build();
    }

    private CodeBlock generateBuilderWithExistingBody(List<? extends RecordComponentElement> components) {
        CodeBlock.Builder body = CodeBlock.builder();
        body.addStatement("Builder builder = new Builder()");
        
        // Copy all values from existing record
        for (RecordComponentElement component : components) {
            String componentName = component.getSimpleName().toString();
            body.addStatement("builder.$N = existing.$N()", componentName, componentName);
        }
        
        body.addStatement("return builder");
        return body.build();
    }

    private MethodSpec generateWithMethod(ClassName recordClass, ClassName companionClass, List<? extends RecordComponentElement> components) {
        ClassName consumerType = ClassName.get("java.util.function", "Consumer");
        ParameterizedTypeName builderConsumerType = ParameterizedTypeName.get(consumerType, companionClass.nestedClass("Builder"));
        
        return MethodSpec.methodBuilder("with")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .addParameter(recordClass, "existing")
            .addParameter(builderConsumerType, "builderModifier")
            .returns(recordClass)
            .addJavadoc("Creates a new record instance by applying modifications to an existing record.\n")
            .addJavadoc("@param existing the existing record to base the new record on\n")
            .addJavadoc("@param builderModifier a consumer that receives a builder initialized with the existing record's values\n")
            .addJavadoc("@return a new record instance with the applied modifications\n")
            .addCode(generateWithMethodBody(components))
            .build();
    }

    private CodeBlock generateWithMethodBody(List<? extends RecordComponentElement> components) {
        CodeBlock.Builder body = CodeBlock.builder();
        body.addStatement("Builder builder = new Builder()");
        
        // Copy all values from existing record
        for (RecordComponentElement component : components) {
            String componentName = component.getSimpleName().toString();
            body.addStatement("builder.$N = existing.$N()", componentName, componentName);
        }
        
        body.addStatement("builderModifier.accept(builder)");
        body.addStatement("return builder.build()");
        
        return body.build();
    }
}