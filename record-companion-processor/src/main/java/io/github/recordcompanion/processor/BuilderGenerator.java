package io.github.recordcompanion.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import java.io.IOException;
import java.util.List;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;

/** Generates builder pattern implementations for record classes. */
public class BuilderGenerator {

  private final ProcessingEnvironment processingEnv;

  public BuilderGenerator(ProcessingEnvironment processingEnv) {
    this.processingEnv = processingEnv;
  }

  /** Generates a companion class with builder methods for the given record. */
  public void generateCompanionClass(TypeElement recordElement) throws IOException {
    String recordName = recordElement.getSimpleName().toString();
    String companionName = recordName + "Companion";
    String packageName =
        processingEnv.getElementUtils().getPackageOf(recordElement).getQualifiedName().toString();

    ClassName recordClass = ClassName.get(packageName, recordName);
    ClassName companionClass = ClassName.get(packageName, companionName);

    List<? extends RecordComponentElement> components = recordElement.getRecordComponents();

    // Generate the Updater interface
    TypeSpec updaterInterface = generateUpdaterInterface(components);

    // Generate the Builder inner class
    TypeSpec builderClass = generateBuilderClass(recordClass, components);

    // Generate the Companion class
    TypeSpec companion =
        TypeSpec.classBuilder(companionName)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addJavadoc(
                "Generated companion class for {@link $T} record with builder pattern support.\n",
                recordClass)
            .addJavadoc("@generated by RecordCompanion annotation processor\n")
            .addType(updaterInterface)
            .addType(builderClass)
            .addMethod(generateBuilderMethod(companionClass))
            .addMethod(generateBuilderWithExistingMethod(recordClass, companionClass, components))
            .addMethod(generateWithMethod(recordClass, companionClass, components))
            .build();

    // Write the companion class to a file
    JavaFile javaFile = JavaFile.builder(packageName, companion).skipJavaLangImports(true).build();

    javaFile.writeTo(processingEnv.getFiler());
  }

  private TypeSpec generateUpdaterInterface(List<? extends RecordComponentElement> components) {
    TypeSpec.Builder updaterBuilder =
        TypeSpec.interfaceBuilder("Updater")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .addJavadoc("Interface for updating record values without exposing build method.\n");

    // Add setter method declarations for each component
    for (RecordComponentElement component : components) {
      String componentName = component.getSimpleName().toString();
      TypeMirror componentType = component.asType();

      MethodSpec setterMethod =
          MethodSpec.methodBuilder(componentName)
              .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
              .addParameter(ClassName.get(componentType), componentName)
              .returns(ClassName.bestGuess("Updater"))
              .addJavadoc("Sets the $N value.\n", componentName)
              .addJavadoc("@param $N the new $N value\n", componentName, componentName)
              .addJavadoc("@return this updater for method chaining\n")
              .build();

      updaterBuilder.addMethod(setterMethod);
    }

    return updaterBuilder.build();
  }

  private TypeSpec generateBuilderClass(
      ClassName recordClass, List<? extends RecordComponentElement> components) {
    TypeSpec.Builder builderBuilder =
        TypeSpec.classBuilder("Builder")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
            .addSuperinterface(ClassName.bestGuess("Updater"));

    // Add fields for each component
    for (RecordComponentElement component : components) {
      builderBuilder.addField(
          ClassName.get(component.asType()),
          component.getSimpleName().toString(),
          Modifier.PRIVATE);
    }

    // Add setter methods for each component
    for (RecordComponentElement component : components) {
      String componentName = component.getSimpleName().toString();
      TypeMirror componentType = component.asType();

      MethodSpec setterMethod =
          MethodSpec.methodBuilder(componentName)
              .addModifiers(Modifier.PUBLIC)
              .addParameter(ClassName.get(componentType), componentName)
              .returns(ClassName.bestGuess("Builder"))
              .addStatement("this.$N = $N", componentName, componentName)
              .addStatement("return this")
              .build();

      builderBuilder.addMethod(setterMethod);
    }

    // Add build() method
    CodeBlock.Builder buildMethodBody = CodeBlock.builder();
    buildMethodBody.add("return new $T(", recordClass);

    for (int i = 0; i < components.size(); i++) {
      if (i > 0) buildMethodBody.add(", ");
      buildMethodBody.add("$N", components.get(i).getSimpleName().toString());
    }
    buildMethodBody.add(")");

    MethodSpec buildMethod =
        MethodSpec.methodBuilder("build")
            .addModifiers(Modifier.PUBLIC)
            .returns(recordClass)
            .addStatement(buildMethodBody.build())
            .build();

    builderBuilder.addMethod(buildMethod);

    return builderBuilder.build();
  }

  private MethodSpec generateBuilderMethod(ClassName companionClass) {
    return MethodSpec.methodBuilder("builder")
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .returns(companionClass.nestedClass("Builder"))
        .addStatement("return new Builder()")
        .addJavadoc("Creates a new builder instance.\n")
        .addJavadoc("@return a new builder instance\n")
        .build();
  }

  private MethodSpec generateBuilderWithExistingMethod(
      ClassName recordClass,
      ClassName companionClass,
      List<? extends RecordComponentElement> components) {
    return MethodSpec.methodBuilder("builder")
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(recordClass, "existing")
        .returns(companionClass.nestedClass("Builder"))
        .addJavadoc(
            "Creates a new builder instance initialized with values from an existing record.\n")
        .addJavadoc("@param existing the existing record to copy values from\n")
        .addJavadoc("@return a new builder instance with copied values\n")
        .addCode(generateBuilderWithExistingBody(components))
        .build();
  }

  private CodeBlock generateBuilderWithExistingBody(
      List<? extends RecordComponentElement> components) {
    CodeBlock.Builder body = CodeBlock.builder();
    body.addStatement("Builder builder = new Builder()");

    // Copy all values from existing record
    for (RecordComponentElement component : components) {
      String componentName = component.getSimpleName().toString();
      body.addStatement("builder.$N = existing.$N()", componentName, componentName);
    }

    body.addStatement("return builder");
    return body.build();
  }

  private MethodSpec generateWithMethod(
      ClassName recordClass,
      ClassName companionClass,
      List<? extends RecordComponentElement> components) {
    ClassName consumerType = ClassName.get("java.util.function", "Consumer");
    ParameterizedTypeName updaterConsumerType =
        ParameterizedTypeName.get(consumerType, companionClass.nestedClass("Updater"));

    return MethodSpec.methodBuilder("with")
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
        .addParameter(recordClass, "existing")
        .addParameter(updaterConsumerType, "updater")
        .returns(recordClass)
        .addJavadoc(
            "Creates a new record instance by applying modifications to an existing record.\n")
        .addJavadoc("@param existing the existing record to base the new record on\n")
        .addJavadoc(
            "@param updater a consumer that receives an updater initialized with the existing record's values\n")
        .addJavadoc("@return a new record instance with the applied modifications\n")
        .addCode(generateWithMethodBody(components))
        .build();
  }

  private CodeBlock generateWithMethodBody(List<? extends RecordComponentElement> components) {
    CodeBlock.Builder body = CodeBlock.builder();
    body.addStatement("Builder builder = new Builder()");

    // Copy all values from existing record
    for (RecordComponentElement component : components) {
      String componentName = component.getSimpleName().toString();
      body.addStatement("builder.$N = existing.$N()", componentName, componentName);
    }

    body.addStatement("updater.accept(builder)");
    body.addStatement("return builder.build()");

    return body.build();
  }
}
